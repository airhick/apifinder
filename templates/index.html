<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>API Key Finder</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #f5f5f5;
            color: #333;
            font-size: 12px;
            line-height: 1.4;
            padding: 16px;
        }
        
        .container {
            max-width: 1600px;
            margin: 0 auto;
        }
        
        .header {
            background: #fff;
            border: 1px solid #e0e0e0;
            border-radius: 4px;
            padding: 16px;
            margin-bottom: 12px;
        }
        
        .header h1 {
            font-size: 18px;
            font-weight: 500;
            color: #222;
            margin-bottom: 4px;
        }
        
        .header p {
            font-size: 11px;
            color: #666;
        }
        
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 8px;
            margin-bottom: 12px;
        }
        
        .stat-card {
            background: #fff;
            border: 1px solid #e0e0e0;
            border-radius: 4px;
            padding: 12px;
        }
        
        .stat-card h3 {
            color: #888;
            font-size: 9px;
            margin-bottom: 6px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .stat-card .value {
            color: #222;
            font-size: 20px;
            font-weight: 500;
        }
        
        .controls {
            background: #fff;
            border: 1px solid #e0e0e0;
            border-radius: 4px;
            padding: 12px;
            margin-bottom: 12px;
        }
        
        .btn {
            padding: 6px 12px;
            border: 1px solid #ddd;
            border-radius: 3px;
            font-size: 11px;
            font-weight: 400;
            cursor: pointer;
            transition: all 0.2s;
            margin-right: 6px;
            background: #fff;
            color: #333;
        }
        
        .btn-primary {
            background: #333;
            color: #fff;
            border-color: #333;
        }
        
        .btn-primary:hover {
            background: #222;
        }
        
        .btn-danger {
            background: #fff;
            color: #d32f2f;
            border-color: #d32f2f;
        }
        
        .btn-danger:hover {
            background: #ffebee;
        }
        
        .btn:disabled {
            opacity: 0.4;
            cursor: not-allowed;
        }
        
        .status-indicator {
            display: inline-block;
            width: 8px;
            height: 8px;
            border-radius: 50%;
            margin-right: 6px;
        }
        
        .status-running {
            background: #4caf50;
        }
        
        .status-stopped {
            background: #9e9e9e;
        }
        
        .logs-container {
            background: #1a1a1a;
            border: 1px solid #333;
            border-radius: 4px;
            padding: 12px;
            height: 400px;
            overflow-y: auto;
            font-family: 'Courier New', monospace;
            font-size: 11px;
            margin-bottom: 12px;
            line-height: 1.6;
        }
        
        .log-entry {
            padding: 3px 0;
            border-bottom: 1px solid #2a2a2a;
            white-space: pre-wrap;
            word-wrap: break-word;
        }
        
        .log-entry:last-child {
            border-bottom: none;
        }
        
        .log-timestamp {
            color: #666;
            margin-right: 8px;
            font-size: 9px;
        }
        
        .log-level-info {
            color: #64b5f6;
            margin-right: 6px;
            font-size: 9px;
        }
        
        .log-level-warning {
            color: #ffb74d;
            margin-right: 6px;
            font-size: 9px;
        }
        
        .log-level-error {
            color: #e57373;
            margin-right: 6px;
            font-size: 9px;
        }
        
        .log-message {
            color: #ccc;
        }
        
        .progress-log {
            color: #4caf50;
            font-weight: 500;
        }
        
        .key-found-log {
            color: #ffd54f;
        }
        
        .success-log {
            color: #81c784;
        }
        
        .error-log {
            color: #e57373;
        }
        
        .timing-log {
            color: #90caf9;
        }
        
        .start-log {
            color: #64b5f6;
            font-weight: 500;
        }
        
        .keys-section {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 12px;
            margin-bottom: 12px;
        }
        
        .keys-container {
            background: #fff;
            border: 1px solid #e0e0e0;
            border-radius: 4px;
            padding: 12px;
            height: 400px;
            display: flex;
            flex-direction: column;
        }
        
        .keys-header {
            font-size: 11px;
            font-weight: 500;
            color: #222;
            margin-bottom: 8px;
            padding-bottom: 8px;
            border-bottom: 1px solid #e0e0e0;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }
        
        .keys-count {
            color: #888;
            font-weight: 400;
        }
        
        .keys-list {
            flex: 1;
            overflow-y: auto;
            font-size: 10px;
        }
        
        .key-item {
            padding: 6px 8px;
            margin: 3px 0;
            background: #f9f9f9;
            border: 1px solid #e8e8e8;
            border-radius: 3px;
            font-family: 'Courier New', monospace;
            word-break: break-all;
            display: flex;
            align-items: center;
            gap: 6px;
        }
        
        .key-item.new-key {
            background: #e8f5e9;
            border-color: #c8e6c9;
        }
        
        .new-icon {
            width: 12px;
            height: 12px;
            background: #4caf50;
            border-radius: 50%;
            flex-shrink: 0;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            font-size: 8px;
            color: white;
            font-weight: bold;
        }
        
        .empty-state {
            color: #999;
            font-size: 10px;
            text-align: center;
            padding: 20px;
        }
        
        .test-section {
            background: #fff;
            border: 1px solid #e0e0e0;
            border-radius: 4px;
            padding: 12px;
            margin-bottom: 12px;
        }
        
        .test-header {
            font-size: 11px;
            font-weight: 500;
            color: #222;
            margin-bottom: 8px;
            padding-bottom: 8px;
            border-bottom: 1px solid #e0e0e0;
        }
        
        .test-controls {
            display: flex;
            gap: 8px;
            margin-bottom: 12px;
            flex-wrap: wrap;
        }
        
        .drop-zone {
            border: 2px dashed #ccc;
            border-radius: 4px;
            padding: 20px;
            text-align: center;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 10px;
            color: #666;
            margin-bottom: 8px;
        }
        
        .drop-zone:hover {
            border-color: #999;
            background: #f9f9f9;
        }
        
        .drop-zone.dragover {
            border-color: #333;
            background: #f0f0f0;
        }
        
        .test-results {
            max-height: 400px;
            overflow-y: auto;
            font-size: 10px;
        }
        
        .test-result-item {
            padding: 8px;
            margin: 4px 0;
            border: 1px solid #e8e8e8;
            border-radius: 3px;
            background: #f9f9f9;
        }
        
        .test-result-item.valid {
            background: #e8f5e9;
            border-color: #c8e6c9;
        }
        
        .test-result-item.invalid {
            background: #ffebee;
            border-color: #ffcdd2;
        }
        
        .test-result-header {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 4px;
        }
        
        .test-status {
            font-weight: 500;
        }
        
        .test-status.valid {
            color: #2e7d32;
        }
        
        .test-status.invalid {
            color: #c62828;
        }
        
        .test-details {
            font-size: 9px;
            color: #666;
            margin-top: 4px;
            padding-left: 20px;
        }
        
        .test-key {
            font-family: 'Courier New', monospace;
            word-break: break-all;
        }
        
        .test-progress {
            font-size: 10px;
            color: #666;
            margin-bottom: 8px;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>API Key Finder</h1>
            <p>Monitor and control the API key discovery process</p>
        </div>
        
        <div class="stats-grid">
            <div class="stat-card">
                <h3>Status</h3>
                <div class="value">
                    <span class="status-indicator" id="statusIndicator"></span>
                    <span id="statusText">Stopped</span>
                </div>
            </div>
            <div class="stat-card">
                <h3>Repos Scanned</h3>
                <div class="value" id="reposScanned">0</div>
            </div>
            <div class="stat-card">
                <h3>Keys Found</h3>
                <div class="value" id="keysFound">0</div>
            </div>
            <div class="stat-card">
                <h3>Working Keys</h3>
                <div class="value" id="keysWorking">0</div>
            </div>
        </div>
        
        <div class="controls">
            <button class="btn btn-primary" id="startBtn" onclick="startCrawler()">Start</button>
            <button class="btn btn-danger" id="stopBtn" onclick="stopCrawler()" disabled>Stop</button>
            <button class="btn" onclick="refreshStats()">Refresh</button>
        </div>
        
        <div class="logs-container" id="logsContainer">
            <div class="log-entry">
                <span class="log-message">Waiting for logs...</span>
            </div>
        </div>
        
        <div class="keys-section">
            <div class="keys-container">
                <div class="keys-header">
                    <span>Found API Keys</span>
                    <div style="display: flex; align-items: center; gap: 8px;">
                        <span class="keys-count" id="foundKeysCount">0</span>
                        <button class="btn" style="padding: 4px 8px; font-size: 9px;" onclick="testFoundKeys()" title="Test all found keys">Test</button>
                    </div>
                </div>
                <div class="keys-list" id="foundKeys">
                    <div class="empty-state">No keys found yet...</div>
            </div>
        </div>
        
        <div class="keys-container">
                <div class="keys-header">
                    <span>Working API Keys</span>
                    <div style="display: flex; align-items: center; gap: 8px;">
                        <span class="keys-count" id="workingKeysCount">0</span>
                        <button class="btn" style="padding: 4px 8px; font-size: 9px;" onclick="testWorkingKeys()" title="Test all working keys">Test</button>
                    </div>
                </div>
                <div class="keys-list" id="workingKeys">
                    <div class="empty-state">No working keys found yet...</div>
                </div>
            </div>
        </div>
        
        <div class="test-section">
            <div class="test-header">Test API Keys</div>
            <div class="test-controls">
                <button class="btn btn-primary" onclick="useFoundKeys()">Test Found Keys</button>
                <button class="btn btn-primary" onclick="testWorkingKeys()">Test Working Keys</button>
                <button class="btn" onclick="stopTesting()" id="stopTestBtn" disabled>Stop</button>
            </div>
            <div class="drop-zone" id="dropZone" onclick="document.getElementById('fileInput').click()">
                <div>üìÅ Drag & drop a .txt file here or click to browse</div>
                <div style="font-size: 9px; color: #999; margin-top: 4px;">One key per line</div>
            </div>
            <input type="file" id="fileInput" accept=".txt" style="display: none;" onchange="handleFileSelect(event)">
            <div class="test-progress" id="testProgress" style="display: none;"></div>
            <div class="test-results" id="testResults">
                <div class="empty-state">No tests run yet. Upload a file or use found keys.</div>
            </div>
        </div>
    </div>
    
    <script>
        let eventSource = null;
        let statusCheckInterval = null;
        
        // Initialize
        document.addEventListener('DOMContentLoaded', function() {
            refreshStats();
            loadExistingLogs();
            startLogStream();
            statusCheckInterval = setInterval(refreshStats, 10000); // Refresh every 10 seconds instead of 5
        });
        
        async function loadExistingLogs() {
            try {
                const response = await fetch('/api/logs');
                const data = await response.json();
                
                if (data.logs && data.logs.length > 0) {
                    const container = document.getElementById('logsContainer');
                    container.innerHTML = '';
                    
                    data.logs.forEach(logEntry => {
                        addLog(logEntry, false);
                    });
                    
                    container.scrollTop = container.scrollHeight;
                }
            } catch (error) {
                console.error('Error loading existing logs:', error);
            }
        }
        
        function startLogStream() {
            if (eventSource) {
                eventSource.close();
            }
            
            eventSource = new EventSource('/api/logs/stream');
            
            eventSource.onmessage = function(event) {
                const data = JSON.parse(event.data);
                if (data.type !== 'heartbeat') {
                    addLog(data);
                }
            };
            
            eventSource.onerror = function(error) {
                console.error('SSE error:', error);
                setTimeout(startLogStream, 3000);
            };
        }
        
        function addLog(logEntry, autoScroll = true) {
            const container = document.getElementById('logsContainer');
            
            if (container.children.length === 1 && container.children[0].textContent.includes('Waiting for logs')) {
                container.innerHTML = '';
            }
            
            const entry = document.createElement('div');
            entry.className = 'log-entry';
            
            const message = logEntry.message;
            
            // Color code based on message content
            let messageClass = 'log-message';
            if (message.includes('üìà')) {
                messageClass += ' progress-log';
            } else if (message.includes('üîë')) {
                messageClass += ' key-found-log';
            } else if (message.includes('‚úÖ')) {
                messageClass += ' success-log';
            } else if (message.includes('‚ùå')) {
                messageClass += ' error-log';
            } else if (message.includes('‚è±Ô∏è')) {
                messageClass += ' timing-log';
            } else if (message.includes('üöÄ')) {
                messageClass += ' start-log';
            }
            
            entry.innerHTML = `<span class="${messageClass}">${escapeHtml(message)}</span>`;
            
            container.appendChild(entry);
            
            if (autoScroll) {
            container.scrollTop = container.scrollHeight;
            }
            
            while (container.children.length > 5000) {
                container.removeChild(container.firstChild);
            }
        }
        
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }
        
        async function startCrawler() {
            try {
                const response = await fetch('/api/start', { method: 'POST' });
                const data = await response.json();
                
                if (response.ok) {
                    updateStatus(true);
                    addLog({
                        timestamp: new Date().toISOString(),
                        level: 'INFO',
                        message: 'üöÄ Crawler started!'
                    });
                } else {
                    alert('Error: ' + data.error);
                }
            } catch (error) {
                console.error('Error starting crawler:', error);
                alert('Failed to start crawler');
            }
        }
        
        async function stopCrawler() {
            try {
                const response = await fetch('/api/stop', { method: 'POST' });
                const data = await response.json();
                
                if (response.ok) {
                    updateStatus(false);
                    addLog({
                        timestamp: new Date().toISOString(),
                        level: 'INFO',
                        message: 'üõë Stop signal sent'
                    });
                } else {
                    alert('Error: ' + data.error);
                }
            } catch (error) {
                console.error('Error stopping crawler:', error);
                alert('Failed to stop crawler');
            }
        }
        
        async function refreshStats() {
            try {
                const [statusRes, statsRes, foundKeysRes, workingKeysRes] = await Promise.all([
                    fetch('/api/status'),
                    fetch('/api/stats'),
                    fetch('/api/keys/found'),
                    fetch('/api/keys/working')
                ]);
                
                const status = await statusRes.json();
                const stats = await statsRes.json();
                const foundKeys = await foundKeysRes.json();
                const workingKeys = await workingKeysRes.json();
                
                updateStatus(status.is_running);
                document.getElementById('reposScanned').textContent = stats.repos_scanned || 0;
                document.getElementById('keysFound').textContent = stats.keys_found || 0;
                document.getElementById('keysWorking').textContent = stats.keys_working || 0;
                
                // Update found keys display
                updateKeysDisplay('foundKeys', foundKeys.keys || [], 'foundKeysCount');
                
                // Update working keys display
                updateKeysDisplay('workingKeys', workingKeys.keys || [], 'workingKeysCount');
            } catch (error) {
                console.error('Error refreshing stats:', error);
            }
        }
        
        function updateKeysDisplay(containerId, keys, countId) {
            const container = document.getElementById(containerId);
            const countElement = document.getElementById(countId);
            
            countElement.textContent = keys.length;
            
            if (keys.length === 0) {
                container.innerHTML = '<div class="empty-state">No keys found yet...</div>';
                return;
            }
            
            // Show most recent keys first, limit to 100
            const displayKeys = keys.slice(-100).reverse();
            
            container.innerHTML = displayKeys.map(keyData => {
                const key = typeof keyData === 'string' ? keyData : keyData.key;
                const isNew = typeof keyData === 'object' && keyData.is_current_run;
                return `
                    <div class="key-item ${isNew ? 'new-key' : ''}">
                        ${isNew ? '<span class="new-icon">N</span>' : ''}
                        <span>${escapeHtml(key)}</span>
                    </div>
                `;
            }).join('');
        }
        
        function updateStatus(isRunning) {
            const indicator = document.getElementById('statusIndicator');
            const text = document.getElementById('statusText');
            const startBtn = document.getElementById('startBtn');
            const stopBtn = document.getElementById('stopBtn');
            
            if (isRunning) {
                indicator.className = 'status-indicator status-running';
                text.textContent = 'Running';
                startBtn.disabled = true;
                stopBtn.disabled = false;
            } else {
                indicator.className = 'status-indicator status-stopped';
                text.textContent = 'Stopped';
                startBtn.disabled = false;
                stopBtn.disabled = true;
            }
        }
        
        // Test API Keys functionality
        let testStatusInterval = null;
        
        const dropZone = document.getElementById('dropZone');
        const fileInput = document.getElementById('fileInput');
        
        // Drag and drop handlers
        dropZone.addEventListener('dragover', (e) => {
            e.preventDefault();
            dropZone.classList.add('dragover');
        });
        
        dropZone.addEventListener('dragleave', () => {
            dropZone.classList.remove('dragover');
        });
        
        dropZone.addEventListener('drop', (e) => {
            e.preventDefault();
            dropZone.classList.remove('dragover');
            const files = e.dataTransfer.files;
            if (files.length > 0 && files[0].name.endsWith('.txt')) {
                handleFile(files[0]);
            }
        });
        
        function handleFileSelect(event) {
            const file = event.target.files[0];
            if (file && file.name.endsWith('.txt')) {
                handleFile(file);
            }
        }
        
        async function handleFile(file) {
            const formData = new FormData();
            formData.append('file', file);
            
            try {
                const response = await fetch('/api/test/keys', {
                    method: 'POST',
                    body: formData
                });
                
                const data = await response.json();
                if (response.ok) {
                    startTestStatusPolling();
                } else {
                    alert('Error: ' + data.error);
                }
            } catch (error) {
                console.error('Error uploading file:', error);
                alert('Failed to upload file');
            }
        }
        
        async function useFoundKeys() {
            try {
                const response = await fetch('/api/test/keys', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({use_found_keys: true})
                });
                
                const data = await response.json();
                if (response.ok) {
                    startTestStatusPolling();
                } else {
                    alert('Error: ' + data.error);
                }
            } catch (error) {
                console.error('Error using found keys:', error);
                alert('Failed to start testing');
            }
        }
        
        async function testFoundKeys() {
            await useFoundKeys();
        }
        
        async function testWorkingKeys() {
            try {
                // Get working keys and create a test file
                const response = await fetch('/api/keys/working');
                const data = await response.json();
                
                if (!data.keys || data.keys.length === 0) {
                    alert('No working keys to test');
                    return;
                }
                
                // Create a file-like object from the keys
                const keysText = data.keys.map(k => k.key || k).join('\n');
                const blob = new Blob([keysText], { type: 'text/plain' });
                const file = new File([blob], 'working_keys.txt', { type: 'text/plain' });
                
                await handleFile(file);
            } catch (error) {
                console.error('Error testing working keys:', error);
                alert('Failed to test working keys');
            }
        }
        
        async function stopTesting() {
            try {
                await fetch('/api/test/stop', { method: 'POST' });
            } catch (error) {
                console.error('Error stopping test:', error);
            }
        }
        
        function startTestStatusPolling() {
            if (testStatusInterval) {
                clearInterval(testStatusInterval);
            }
            
            document.getElementById('stopTestBtn').disabled = false;
            document.getElementById('testProgress').style.display = 'block';
            document.getElementById('testResults').innerHTML = '';
            
            testStatusInterval = setInterval(async () => {
                try {
                    const response = await fetch('/api/test/status');
                    const data = await response.json();
                    
                    updateTestProgress(data);
                    updateTestResults(data.results || []);
                    
                    if (!data.testing) {
                        clearInterval(testStatusInterval);
                        document.getElementById('stopTestBtn').disabled = true;
                        testStatusInterval = null;
                    }
                } catch (error) {
                    console.error('Error fetching test status:', error);
                }
            }, 2000); // Poll every 2 seconds instead of 1
        }
        
        function updateTestProgress(data) {
            const progressEl = document.getElementById('testProgress');
            if (data.testing) {
                progressEl.textContent = `Testing: ${data.total_tested} / ${data.total_tested + (data.testing ? '?' : '')} | Valid: ${data.total_valid} | Invalid: ${data.total_invalid}`;
            } else if (data.total_tested > 0) {
                progressEl.textContent = `Complete: ${data.total_tested} tested | Valid: ${data.total_valid} | Invalid: ${data.total_invalid}`;
            }
        }
        
        function updateTestResults(results) {
            const container = document.getElementById('testResults');
            
            if (results.length === 0) {
                container.innerHTML = '<div class="empty-state">No tests run yet. Upload a file or use found keys.</div>';
                return;
            }
            
            // Show most recent results first (newest at top)
            const displayResults = results.slice().reverse();
            
            container.innerHTML = displayResults.map(result => {
                const isValid = result.is_valid;
                const statusClass = isValid ? 'valid' : 'invalid';
                const statusText = isValid ? '‚úÖ Valid' : '‚ùå Invalid';
                const statusColorClass = isValid ? 'valid' : 'invalid';
                
                // Format response text
                let responseText = '';
                if (result.response) {
                    const resp = result.response.substring(0, 200);
                    responseText = `<div><strong>Server Response:</strong> ${escapeHtml(resp)}${result.response.length > 200 ? '...' : ''}</div>`;
                }
                
                return `
                    <div class="test-result-item ${statusClass}">
                        <div class="test-result-header">
                            <span class="test-status ${statusColorClass}">${statusText}</span>
                            <span style="color: #888; font-size: 9px;">[${result.index}/${result.total}]</span>
                            <span style="color: #888; font-size: 9px;">${result.key_type || 'unknown'}</span>
                        </div>
                        <div class="test-key">${escapeHtml(result.key_full || result.key)}</div>
                        <div class="test-details">
                            <div><strong>Result:</strong> ${escapeHtml(result.message || 'N/A')}</div>
                            ${result.status_code ? `<div><strong>HTTP Status:</strong> ${result.status_code}</div>` : ''}
                            ${responseText}
                        </div>
                    </div>
                `;
            }).join('');
            
            // Auto-scroll to top to see latest results
            container.scrollTop = 0;
        }
    </script>
</body>
</html>
